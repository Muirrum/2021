//------------------------------------------------------------------------------
//  game.c
//------------------------------------------------------------------------------
#define HANDMADE_MATH_IMPLEMENTATION
#define HANDMADE_MATH_NO_SSE
#include "HandmadeMath.h"

#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_glue.h"
#include "./build/game.glsl.h"
#include <stdio.h>

static struct {
    float rx, ry;
    sg_pipeline pip;
    sg_bindings bind;
} state;


typedef struct {
	hmm_vec3 pos;
	hmm_vec3 norm;
} Vertex;

Vertex vert_pos(hmm_vec3 pos) {
	return (Vertex){
		.pos = pos,
		.norm = HMM_Vec3(0, 0, 0),
	};
}

#define DETAIL 3
#define SIZE (1 << DETAIL)
#define LEN(arr) (int) (sizeof arr / sizeof arr[0])
typedef struct {
	uint16_t indices[12 * SIZE * SIZE * 5];
	Vertex vertices[12 * SIZE * SIZE];
	uint16_t vert_writer;
} Geometry;

uint16_t vert_insert(Geometry *geo, Vertex vert) {
	for (uint16_t i = 0; i < geo->vert_writer; i++)
		if (HMM_EqualsVec3(geo->vertices[i].pos, vert.pos))
			return i;

	geo->vertices[geo->vert_writer] = vert;
	return geo->vert_writer++;
}

Geometry geometry() {
	Geometry geo;
	geo.vert_writer = 0;
	for (int i = 0; i < 12 * SIZE * SIZE * 5; i++) {
		if (i < LEN(geo.vertices))
			geo.vertices[i] = vert_pos(HMM_Vec3(0.0, 0.0, 0.0));
		geo.indices[i] = 0;
	}

    /* icosahedron vertex buffer */
	float t = 1.0f + sqrtf(5.0f) / 2.0f;
    hmm_vec3 vert_poses[] = {
		HMM_Vec3(-1.0,    t,  0.0),
		HMM_Vec3( 1.0,    t,  0.0),
		HMM_Vec3(-1.0,   -t,  0.0),
		HMM_Vec3( 1.0,   -t,  0.0),
		HMM_Vec3( 0.0, -1.0,    t),
		HMM_Vec3( 0.0,  1.0,    t),
		HMM_Vec3( 0.0, -1.0,   -t),
		HMM_Vec3( 0.0,  1.0,   -t),
		HMM_Vec3(   t,  0.0, -1.0),
		HMM_Vec3(   t,  0.0,  1.0),
		HMM_Vec3(  -t,  0.0, -1.0),
		HMM_Vec3(  -t,  0.0,  1.0),
    };

    /* create an index buffer for the icosahedron */
    uint16_t base_indices[] = {
		 0, 11,  5,
		 0,  5,  1,
		 0,  1,  7,
		 0,  7, 10,
		 0, 10, 11,
		 1,  5,  9,
		 5, 11,  4,
		11, 10,  2,
		10,  7,  6,
		 7,  1,  8,
		 3,  9,  4,
		 3,  4,  2,
		 3,  2,  6,
		 3,  6,  8,
		 3,  8,  9,
		 4,  9,  5,
		 2,  4, 11,
		 6,  2, 10,
		 8,  6,  7,
		 9,  8,  1,
    };
	
	int index_writer = 0;
	size_t tri, x, y, rows;
	hmm_vec3 a, b, c, ay, by, v[SIZE + 1][SIZE + 1];
	for (tri = 0; tri < LEN(base_indices); tri += 3) {
		a = vert_poses[base_indices[tri + 0]],
		b = vert_poses[base_indices[tri + 1]],
		c = vert_poses[base_indices[tri + 2]];
		for (x = 0; x <= SIZE; x++) {
			ay = HMM_LerpVec3(a, (float) x / (float) SIZE, c),
			by = HMM_LerpVec3(b, (float) x / (float) SIZE, c);
			rows = SIZE - x;
			for (y = 0; y <= rows; y++)
				if (y == 0 && x == SIZE)
					v[x][y] = ay;
				else 
					v[x][y] = HMM_LerpVec3(ay, (float) y / (float) rows, by);
		}

		for (x = 0; x < SIZE; x++) {
			for (y = 0; y < 2 * (SIZE - x) - 1; y++) {
				int k = (int) floorf((float) y / 2.0f);
				if (y % 2 == 0) {
					geo.indices[index_writer++] = vert_insert(&geo, vert_pos(v[x    ][k + 1]));
					geo.indices[index_writer++] = vert_insert(&geo, vert_pos(v[x + 1][k    ]));
					geo.indices[index_writer++] = vert_insert(&geo, vert_pos(v[x    ][k    ]));
				} else {
					geo.indices[index_writer++] = vert_insert(&geo, vert_pos(v[x    ][k + 1]));
					geo.indices[index_writer++] = vert_insert(&geo, vert_pos(v[x + 1][k + 1]));
					geo.indices[index_writer++] = vert_insert(&geo, vert_pos(v[x + 1][k    ]));
				}
			}
		}
	}

	for (size_t i = 0; i < LEN(geo.vertices); i++) {
		geo.vertices[i].norm = HMM_NormalizeVec3(geo.vertices[i].pos);
		geo.vertices[i].pos = geo.vertices[i].norm;
	}

	return geo;
}

void init(void) {
    sg_setup(&(sg_desc){
        .context = sapp_sgcontext()
    });
	
	Geometry geo = geometry();
    sg_buffer vbuf = sg_make_buffer(&(sg_buffer_desc){
        .size = sizeof geo.vertices,
        .content = geo.vertices,
        .label = "icosahedron-vertices"
    });
    sg_buffer ibuf = sg_make_buffer(&(sg_buffer_desc){
        .type = SG_BUFFERTYPE_INDEXBUFFER,
        .size = sizeof geo.indices,
        .content = geo.indices,
        .label = "icosahedron-indices"
    });

    /* create shader */
    sg_shader shd = sg_make_shader(cube_shader_desc());

    /* create pipeline object */
    state.pip = sg_make_pipeline(&(sg_pipeline_desc){
        .layout = {
            .attrs = {
                [ATTR_vs_position].format = SG_VERTEXFORMAT_FLOAT3,
                [ATTR_vs_normal].format = SG_VERTEXFORMAT_FLOAT3,
            }
        },
        .shader = shd,
        .index_type = SG_INDEXTYPE_UINT16,
        .depth_stencil = {
            .depth_compare_func = SG_COMPAREFUNC_LESS_EQUAL,
            .depth_write_enabled = true,
        },
        .rasterizer.cull_mode = SG_CULLMODE_BACK,
        .label = "icosahedron-pipeline"
    });

    /* setup resource bindings */
    state.bind = (sg_bindings) {
        .vertex_buffers[0] = vbuf,
        .index_buffer = ibuf
    };
}

void frame(void) {
    /* NOTE: the vs_params_t struct has been code-generated by the shader-code-gen */
    vs_params_t vs_params;
    const float w = (float) sapp_width();
    const float h = (float) sapp_height();
    hmm_mat4 proj = HMM_Perspective(60.0f, w/h, 0.01f, 10.0f);
    hmm_mat4 view = HMM_LookAt(HMM_Vec3(0.0f, 1.5f, 6.0f), HMM_Vec3(0.0f, 0.0f, 0.0f), HMM_Vec3(0.0f, 1.0f, 0.0f));
    hmm_mat4 view_proj = HMM_MultiplyMat4(proj, view);
    state.rx += 1.0f; state.ry += 2.0f;
    hmm_mat4 rxm = HMM_Rotate(state.rx, HMM_Vec3(1.0f, 0.0f, 0.0f));
    hmm_mat4 rym = HMM_Rotate(state.ry, HMM_Vec3(0.0f, 1.0f, 0.0f));
    hmm_mat4 model = HMM_MultiplyMat4(rxm, rym);
    vs_params.mvp = HMM_MultiplyMat4(view_proj, model);

    sg_pass_action pass_action = {
        .colors[0] = { .action = SG_ACTION_CLEAR, .val = {0.17f, 0.02f, 0.22f, 1.0f} }
    };
    sg_begin_default_pass(&pass_action, (int)w, (int)h);
    sg_apply_pipeline(state.pip);
    sg_apply_bindings(&state.bind);
    sg_apply_uniforms(SG_SHADERSTAGE_VS, SLOT_vs_params, &vs_params, sizeof vs_params );
    sg_draw(0, 3840, 1);
    sg_end_pass();
    sg_commit();
}

void cleanup(void) {
    sg_shutdown();
}

sapp_desc sokol_main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;

    return (sapp_desc){
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .width = 800,
        .height = 600,
        .sample_count = 4,
        .gl_force_gles2 = true,
        .window_title = "Cube (sokol-app)",
    };
}
